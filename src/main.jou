import "stdlib/ascii.jou"
import "stdlib/io.jou"
import "stdlib/list.jou"
import "stdlib/math.jou"
import "stdlib/mem.jou"
import "stdlib/str.jou"
import "stdlib/process.jou"


def fail(args: CommandLineArgs*, msg: byte*) -> noreturn:
    fprintf(get_stderr(), "%s: %s\n", args.program_name, msg)
    exit(1)


# TODO(Jou): belongs to stdlib
declare strtod(nptr: byte*, endptr: byte**) -> double

def parse_double_between_0_and_1(s: byte*, result: double*) -> bool:
    end: byte*
    *result = strtod(s, &end)
    return (
        end > s  # not empty string
        and *end == '\0'  # no junk after the number
        and *result >= 0
        and *result <= 1
        and *result == *result  # not NaN
    )


# The calculate_*_multiplier() functions work with values between 0 and 1. They
# determine how much light of each color should be filtered.
#
# The input x is a visibility value:
#   0 = user wants black screen
#   1 = user wants to do nothing
#
# The output is a multiplier for colors:
#   0 = all colors become black
#   1 = colors do not change
#
# So these functions return inputs 0 and 1 unchanged, but the interesting thing
# is what they do between 0 and 1.
#
# These functions were inspired by the hard-coded table in the redshift
# program, but are not exactly the same.
#
# You can use https://akuli.github.io/grapher/ to visualize these functions.
# The visibility value is named "x" so that you can copy/paste there easily.
def calculate_red_multiplier(x: double) -> double:
    # Linearly slide from 0 to 1 on [0, 0.15], then stay at 1
    return fmin(x / 0.15, 1)

def calculate_green_multiplier(x: double) -> double:
    # redshift's curve is close to a sideways parabola with peak at (0.15,0.15)
    # and passing through point (1,1). This is basically y=x with some extra
    # curviness to somewhat follow the parabola.
    #return x + x*pow(1-x, 1.3)
    return x + 6*x*(x-0.15)*pow(1-x, 2.5)

def calculate_blue_multiplier(x: double) -> double:
    # redshift's curve is again close to a sideways parabola through (1,1), but
    # now peak is at about (0.3, 0). I spent way too much time trying to come
    # up with curves to somewhat follow that parabola...

    #return x - (sin(4*x) / 4)*(1 - x*x)
    return 10*pow(x,4) / (9*pow(x,4) + 1)
    #return fmax((x - 0.3) / (1 - 0.3), 0)  # linear slide from 0 to 1 on [0.3, 1]


def print_help(program_name: byte*) -> None:
    printf("Usage:\n")
    printf("  %s [options] \"STATE\"\n", program_name)
    printf("  %s [options] \"STATE1 @ hh:mm\" \"STATE2 @ hh:mm\" ...\n", program_name)
    printf("\n")
    printf("Options:\n")
    printf("  --help          this message\n")
    printf("  --allow-dark    allow making the screen very dark\n")
    printf("  --smoothstep    use the smoothstep function instead of linear interpolation\n")
    printf("\n")
    printf("The simplest way to specify a state is a number between 0 and 1. Here 0 means\n")
    printf("black screen, 1 means reset, and values between 0 and 1 filter out mostly blue\n")
    printf("light. For example, I use 0.6 during the day to make the screen look comfy and\n")
    printf("easy on my eyes.\n")
    printf("\n")
    printf("The SETTING can also be R, G and B numbers between 0 and 1 separated by spaces.\n")
    printf("For example, \"0.5 0.5 0.5\" basically decreases brightness, and \"1 1 0\" filters\n")
    printf("out all blue light (probably not what you want).\n")
    printf("\n")
    printf("If you specify multiple states, they must have \"@ hh:mm\" (hour and minute) or\n")
    printf("\"@ hh\" (hour) at the end to specify when the state should apply: \"0.6 @ 22\"\n")
    printf("means that value 0.6 will be used if you run the command at 22:00 (10PM). The\n")
    printf("values are interpolated at other times (linearly by default).\n")


class State:
    r_multiplier: double
    g_multiplier: double
    b_multiplier: double
    original_color_string: byte[100]

    hour: int
    minute: int


class CommandLineArgs:
    program_name: byte*
    states: List[State]
    allow_dark: bool
    smoothstep: bool

    @public
    def print(self) -> None:
        printf("program_name = %s\n", self.program_name)
        printf("allow_dark = %s\n", "True" if self.allow_dark else "False")
        printf("smoothstep = %s\n", "True" if self.smoothstep else "False")
        printf("states (%zd):\n", self.states.len)

        for i = 0; i < self.states.len; i++:
            s = &self.states.ptr[i]
            printf(
                "  [%d] R=%.3f  G=%.3f  B=%.3f",
                i, s.r_multiplier, s.g_multiplier, s.b_multiplier,
            )
            if s.hour >= 0 and s.minute >= 0:
                printf("  @ %02d:%02d\n", s.hour, s.minute)
            else:
                printf("  (no time)\n")


def parse_time(args: CommandLineArgs*, s: byte*) -> int[2]:
    s = strdup(s)
    trim_ascii_whitespace(s)

    if strlen(s) < 8:  # short enough to not overflow int
        colon_count = 0
        for i = 0; s[i] != '\0'; i++:
            if s[i] == ':':
                colon_count++
            elif not is_ascii_digit(s[i]):
                colon_count = -1
                break

        if colon_count == 0 or colon_count == 1:
            hour = atoi(s)
            minute = atoi(&strstr(s, ":")[1]) if colon_count == 1 else 0
            if 0 <= hour and hour <= 24 and 0 <= minute and minute <= 60:
                free(s)
                return [hour, minute]

    msg: byte[300]
    snprintf(msg, sizeof(msg), "invalid time \"%s\" (try --help)", s)
    fail(args, msg)


def parse_spec(args: CommandLineArgs*, s: byte*) -> None:
    s = strdup(s)
    state = State{}

    at = strstr(s, "@")
    if at != NULL:
        hour_and_minute = parse_time(args, &at[1])
        state.hour = hour_and_minute[0]
        state.minute = hour_and_minute[1]
        *at = '\0'
    else:
        state.hour = -1
        state.minute = -1

    trim_ascii_whitespace(s)
    snprintf(state.original_color_string, sizeof(state.original_color_string), "%s", s)

    parts = split_by_ascii_whitespace(s)
    value: double

    if parts.len == 1 and parse_double_between_0_and_1(parts.ptr[0], &value):
        state.r_multiplier = calculate_red_multiplier(value)
        state.g_multiplier = calculate_green_multiplier(value)
        state.b_multiplier = calculate_blue_multiplier(value)
    elif (
        parts.len == 3
        and parse_double_between_0_and_1(parts.ptr[0], &state.r_multiplier)
        and parse_double_between_0_and_1(parts.ptr[1], &state.g_multiplier)
        and parse_double_between_0_and_1(parts.ptr[2], &state.b_multiplier)
    ):
        pass  # all good, no need to do anything
    else:
        msg: byte[300]
        snprintf(msg, sizeof(msg), "invalid state \"%s\" (try --help)", state.original_color_string)
        fail(args, msg)

    free(parts.ptr)
    free(s)
    args.states.append(state)


# Public for tests
@public
def parse_command_line_args(argc: int, argv: byte**) -> CommandLineArgs:
    args = CommandLineArgs{program_name = argv[0]}
    msg: byte[300]

    for i = 1; i < argc; i++:
        match argv[i] with strcmp:
            case "--help":
                print_help(args.program_name)
                exit(0)
            case "--allow-dark":
                args.allow_dark = True
            case "--smoothstep":
                args.smoothstep = True
            case _:
                if argv[i][0] == '-':
                    snprintf(msg, sizeof(msg), "unknown option \"%s\" (try --help)", argv[i])
                    fail(&args, msg)
                parse_spec(&args, argv[i])

    match args.states.len:
        case 0:
            fail(&args, "please specify how to color the screen (try --help)")
        case 1:
            if args.states.ptr[0].hour >= 0 and args.states.ptr[0].minute >= 0:
                fail(&args, "a time cannot be specified if you give just one state (try --help)")
            if args.smoothstep:
                fail(&args, "--smoothstep can be used only if you specify multiple states (try --help)")
        case _:
            for s = args.states.ptr; s < args.states.end(); s++:
                if s.hour < 0 or s.minute < 0:
                    fail(&args, "when you specify multiple states, you must use '@' to specify a time for each state")

    if not args.allow_dark:
        for s = &args.states.ptr[0]; s < args.states.end(); s++:
            # Not perfect, but good enough for this.
            # Note that the magic numbers sum to 1 so this is a weighted average.
            brightness = 0.2126*s.r_multiplier + 0.7152*s.g_multiplier + 0.0722*s.b_multiplier

            # The threshold value must be less than any coefficient above, so that you
            # can easily (without --allow-dark) figure out what each color by itself
            # does. For example, threshold 0.08 is too big, because "0 0 1" would fail.
            if brightness < 0.07:
                snprintf(
                    msg, sizeof(msg),
                    "refusing because \"%s\" would make the screen very dark, use --allow-dark if that's really what you want",
                    s.original_color_string,
                )
                fail(&args, msg)

    return args


def main(argc: int, argv: byte**) -> int:
    args = parse_command_line_args(argc, argv)
    args.print()
    return 0
