import "stdlib/ascii.jou"
import "stdlib/io.jou"
import "stdlib/math.jou"
import "stdlib/mem.jou"
import "stdlib/str.jou"
import "stdlib/process.jou"


def fail(args: CommandLineArgs*, msg: byte*) -> noreturn:
    fprintf(get_stderr(), "%s: %s\n", args.program_name, msg)
    exit(1)


# TODO(Jou): belongs to stdlib
declare strtod(nptr: byte*, endptr: byte**) -> double

def string_to_double_between_0_and_1(args: CommandLineArgs*, s: byte*) -> double:
    end: byte*
    value = strtod(s, &end)
    msg: byte[200]

    if end == s or *end != '\0':
        snprintf(msg, sizeof(msg), "invalid number \"%s\" (try --help)", s)
        fail(args, msg)

    if value < 0 or value > 1:
        snprintf(msg, sizeof(msg), "value \"%s\" must be between 0 and 1", s)
        fail(args, msg)

    return value


# The calculate_*_multiplier() functions work with values between 0 and 1. They
# determine how much light of each color should be filtered.
#
# The input x is a visibility value:
#   0 = user wants black screen
#   1 = user wants to do nothing
#
# The output is a multiplier for colors:
#   0 = all colors become black
#   1 = colors do not change
#
# So these functions return inputs 0 and 1 unchanged, but the interesting thing
# is what they do between 0 and 1.
#
# These functions were inspired by the hard-coded table in the redshift
# program, but are not exactly the same.
#
# You can use https://akuli.github.io/grapher/ to visualize these functions.
# The visibility value is named "x" so that you can copy/paste there easily.
def calculate_red_multiplier(x: double) -> double:
    # Linearly slide from 0 to 1 on [0, 0.15], then stay at 1
    return fmin(x / 0.15, 1)

def calculate_green_multiplier(x: double) -> double:
    # redshift's curve is close to a sideways parabola with peak at (0.15,0.15)
    # and passing through point (1,1). This is basically y=x with some extra
    # curviness to somewhat follow the parabola.
    #return x + x*pow(1-x, 1.3)
    return x + 6*x*(x-0.15)*pow(1-x, 2.5)

def calculate_blue_multiplier(x: double) -> double:
    # redshift's curve is again close to a sideways parabola through (1,1), but
    # now peak is at about (0.3, 0). I spent way too much time trying to come
    # up with curves to somewhat follow that parabola...

    #return x - (sin(4*x) / 4)*(1 - x*x)
    return 10*pow(x,4) / (9*pow(x,4) + 1)
    #return fmax((x - 0.3) / (1 - 0.3), 0)  # linear slide from 0 to 1 on [0.3, 1]


def print_help(program_name: byte*) -> None:
    printf("Usage: %s [--allow-dark] [--smoothstep] \"SPEC\" [\"SPEC\" ...]\n", program_name)
    printf("\n")
    printf("Options:\n")
    printf("  --help          this message\n")
    printf("  --allow-dark    allow making the screen very dark\n")
    printf("  --smoothstep    use the smoothstep function instead of linear interpolation\n")
    printf("\n")
    printf("The simplest possible SPEC is a number between 0 (black screen) and 1 (reset).\n")
    printf("Values between 0 and 1 filter out mostly blue right. For example, I use 0.6\n")
    printf("during the day to make the screen look comfy and easier on the eyes.\n")
    printf("\n")
    printf("The SPEC can also be R, G and B values between 0 and 1 separated by spaces. For\n")
    printf("example, \"0.5 0.5 0.5\" basically decreases brightness.\n")
    printf("\n")
    printf("If you specify multiple SPECs, each SPEC must have \"@ hh:mm\" (hour and minute)\n")
    printf("or \"@ hh\" (hour) at the end to specify when the spec should apply: \"0.6 @ 22\"\n")
    printf("means that value 0.6 will be used if you run the command at 22:00 (10PM). The\n")
    printf("values are interpolated at other times (linearly by default).\n")


class Spec:
    r_multiplier: double
    g_multiplier: double
    b_multiplier: double
    hour: int
    minute: int


class CommandLineArgs:
    program_name: byte*
    specs: Spec[100]
    nspecs: int
    allow_dark: bool
    smoothstep: bool

    def print(self: CommandLineArgs*) -> None:
        printf("program_name = %s\n", self.program_name)
        printf("allow_dark   = %d\n", self.allow_dark)
        printf("smoothstep   = %d\n", self.smoothstep)
        printf("specs (%d):\n", self.nspecs)

        for i = 0; i < self.nspecs; i++:
            s = &self.specs[i]
            printf(
                "  [%d] R=%.3f  G=%.3f  B=%.3f",
                i, s.r_multiplier, s.g_multiplier, s.b_multiplier,
            )
            if s.hour >= 0:
                printf("  @ %02d:%02d\n", s.hour, s.minute)
            else:
                printf("  (no time)\n")


def parse_time(args: CommandLineArgs*, s: byte*) -> int[2]:
    s = strdup(s)
    trim_ascii_whitespace(s)

    if strlen(s) < 8:  # short enough to not overflow int
        colon_count = 0
        for i = 0; s[i] != '\0'; i++:
            if s[i] == ':':
                colon_count++
            elif not is_ascii_digit(s[i]):
                colon_count = -1
                break

        if colon_count == 0:
            free(s)
            return [atoi(s), 0]
        if colon_count == 1:
            free(s)
            return [atoi(s), atoi(&strstr(s, ":")[1])]

    msg: byte[300]
    snprintf(msg, sizeof(msg), "invalid time \"%s\" (try --help)", s)
    fail(args, msg)


def parse_spec(args: CommandLineArgs*, s: byte*) -> None:
    if args.nspecs == array_count(args.specs):
        fail(args, "too many arguments")

    s = strdup(s)
    spec = &args.specs[args.nspecs++]

    at = strstr(s, "@")
    if at != NULL:
        hour_and_minute = parse_time(args, &at[1])
        spec.hour = hour_and_minute[0]
        spec.minute = hour_and_minute[1]
        *at = '\0'
    else:
        spec.hour = -1
        spec.minute = -1

    parts = split_by_ascii_whitespace(s)
    match parts.len:
        case 1:
            value = string_to_double_between_0_and_1(args, parts.ptr[0])
            spec.r_multiplier = calculate_red_multiplier(value)
            spec.g_multiplier = calculate_green_multiplier(value)
            spec.b_multiplier = calculate_blue_multiplier(value)
        case 3:
            spec.r_multiplier = string_to_double_between_0_and_1(args, parts.ptr[0])
            spec.g_multiplier = string_to_double_between_0_and_1(args, parts.ptr[1])
            spec.b_multiplier = string_to_double_between_0_and_1(args, parts.ptr[2])
        case _:
            msg: byte[300]
            snprintf(msg, sizeof(msg), "expected 1 or 3 numbers, got %zd numbers in \"%s\" (try --help)", s, parts.len)
            fail(args, msg)

    free(parts.ptr)
    free(s)


def main(argc: int, argv: byte**) -> int:
    args = CommandLineArgs{program_name = argv[0]}

    for i = 1; i < argc; i++:
        match argv[i] with strcmp:
            case "--help":
                print_help(args.program_name)
                return 0
            case "--allow-dark":
                args.allow_dark = True
            case "--smoothstep":
                args.smoothstep = True
            case _:
                if argv[i][0] == '-':
                    msg: byte[300]
                    snprintf(msg, sizeof(msg), "unknown option \"%s\" (try --help)", argv[i])
                    fail(&args, msg)
                parse_spec(&args, argv[i])

    args.print()

#    # Not perfect, but good enough for this.
#    # Note that the magic numbers sum to 1 so this is a weighted average.
#    brightness = 0.2126*(*r) + 0.7152*(*g) + 0.0722*(*b)
#
#    # The threshold value must be less than any coefficient above, so that you
#    # can easily (without --allow-dark) figure out what each color by itself
#    # does. For example, threshold 0.08 is too big, because "0 0 1" would fail.
#    if brightness < 0.07 and not force:
#        fprintf(get_stderr(), "%s: refusing because screen would become very dark, use --force if that's really what you want\n", program_name)
#        exit(1)

    return 0
